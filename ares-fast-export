#!/usr/bin/env python3
import datetime
import io
import os
import os.path
import re
import shutil
import sys
import tarfile
import zipfile
from typing import NamedTuple


FULL_RELEASE_RE = re.compile(r"v\d+$")


class Release(NamedTuple):
    date: datetime.datetime
    version: str
    changelog: str
    archive_path: str


def iter_releases():
    with open("releases.txt", "r") as handle:
        for line in handle:
            date, version, archive_path = line.strip().split("\t")
            pretty_version = version.replace("_", " ")

            date = datetime.datetime.fromisoformat(date)
            changelog_path = f"./changes/{version}.changelog"

            with open(changelog_path, "rb") as changelog_handle:
                changelog = (
                    b"Update to %s release.\n\n" % pretty_version.encode("utf-8")
                    + changelog_handle.read().rstrip()
                )

            yield Release(date, version, changelog, archive_path)


class ArchiveFile(NamedTuple):
    path: str
    size: int
    handle: io.BufferedReader


def iter_files(archive):
    empty_dirs = set()

    if archive.endswith(".tar.xz"):
        with tarfile.open(archive) as handle:
            for info in iter(handle.next, None):
                # For some reason, the ares_20210516b.tar.xz archive
                # includes an "ares/" prefix on every path.
                # To make it match the contents of other archives,
                # we'll strip the first path segment off every file.
                if archive.endswith("ares_20210516b.tar.xz"):
                    if "/" not in info.name:
                        # This is not in a subdirectory, we don't care
                        continue
                    else:
                        # This is something in a subdirectory, bring it out.
                        path = info.name.split("/", 1)[1]
                else:
                    path = info.name
                if not path:
                    continue

                # This path's's parent clearly isn't an empty directory.
                empty_dirs.discard(os.path.dirname(path))

                if info.isdir():
                    # This directory may be empty.
                    empty_dirs.add(path)

                elif info.isfile():
                    yield ArchiveFile(
                        path=path,
                        size=info.size,
                        handle=handle.extractfile(info),
                    )

                # Git doesn't care about non-files.

    elif archive.endswith(".zip"):
        with zipfile.ZipFile(archive) as handle:
            for info in handle.infolist():
                # Official releases were published in .zip files
                # and put the source files into a named subdirectory
                # instead of the root of the archive.
                # Therefore, for zip files, we trim off
                # the first path component.
                # Also, Zip files store directories with a trailing slash,
                # so let's git rid of that too.
                path = info.filename.split("/", 1)[1].rstrip("/")
                if not path:
                    continue

                # WIP tarballs included a script to download
                # the ParaLLEl-RDP source from GitHub,
                # but releases included the source itself,
                # including the `.git` metadata.
                # For consistency, let's not include any of that;
                # we can subtree the repo in later.
                if "parallel-rdp" in path:
                    continue

                # This path's parent clearly isn't an empty directory.
                empty_dirs.discard(os.path.dirname(path))

                if info.is_dir():
                    # This directory may be empty.
                    empty_dirs.add(path)

                else:
                    yield ArchiveFile(
                        path=path,
                        size=info.file_size,
                        handle=handle.open(info),
                    )

    for dir in empty_dirs:
        if dir[-4:] == "/obj" or dir[-4:] == "/out":
            gitignore=b"*\n!.gitignore\n"
        else:
            gitignore=b""

        yield ArchiveFile(
            path=dir + "/.gitignore",
            size=len(gitignore),
            handle=io.BytesIO(gitignore),
        )


def write(bytes):
    sys.stdout.buffer.write(bytes)


def produce_history(releases):
    for mark, release in enumerate(releases, 1):
        write(b"progress Committing version %s\n" %
            release.version.encode("utf-8")
        )
        write(b"commit refs/heads/ares\n")
        write(b"mark :%d\n" % mark)
        write(b"committer %s %d +0000\n" % (
                b"Near <77224854+near-san@users.noreply.github.com>",
                release.date.timestamp(),
        ))

        write(b"data %d\n" % len(release.changelog))
        write(release.changelog)
        write(b"\n")

        # We're going to replace the previous release with a new one.
        write(b"deleteall\n")

        for each in iter_files(release.archive_path):
            write(b"M 100644 inline %s\n" % each.path.encode("utf-8"))
            write(b"data %d\n" % each.size)
            shutil.copyfileobj(each.handle, sys.stdout.buffer)
            write(b"\n")

        m = FULL_RELEASE_RE.search(release.version)
        if m is not None:
            write(b"reset refs/tags/%s\n" % m.group().encode("utf-8"))
            write(b"from :%d\n" % mark)


def main(args):
    os.chdir(os.path.dirname(args[0]))

    write(b"reset refs/heads/ares\n")
    write(b"from refs/tags/v110\n")

    produce_history(iter_releases())

    write(b"done\n")

    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv))
